%!PS-Adobe-3.0 EPSF-3.0
%%Creator: tzunghaor svg2eps
%%Pages: 1
%%DocumentData: Clean7Bit
%%LanguageLevel: 3
%%DocumentNeededResources: procset Adobe_Illustrator_AI5 1.3 0
%AI5_FileFormat 3
%%BoundingBox: 0 0 3750 2250
%%HiResBoundingBox: 0 0 3750.000000 2250.000000
%AI5_ArtSize: 3750.000000 2250.000000
%%EndComments

%%BeginProlog
100 dict begin
/tzung_eps_state save def
/dict_count countdictstack def
/op_count count 1 sub def
/Adobe_Illustrator_AI5 where
{ pop } {
    /tzung_strokergb [ 0 0 0 ] def
    /tzung_compound 0 def
    /tzung_closeop { S } def
    /tzung_fillrule 0 def

    /*u { /tzung_compound 1 def newpath /tzung_fillrule 0 def } bind def
    /*U { /tzung_compound 0 def tzung_closeop  } bind def
    /u {} bind def
    /U {} bind def

    /q { clipsave } bind def
    /Q { cliprestore } bind def
    /W { clip } bind def

    /Lb { 10 {pop} repeat } bind def
    /Ln {pop} bind def
    /LB {} bind def


    /w { setlinewidth } bind def
    /J { setlinecap } bind def
    /j { setlinejoin } bind def
    /M { setmiterlimit } bind def
    /d { setdash } bind def

    /m { tzung_compound 0 eq { newpath /tzung_fillrule 0 def } if moveto } bind def
    /l { lineto } bind def
    /c { curveto } bind def

    /XR { /tzung_fillrule exch def } bind def
    /Xa { setrgbcolor } bind def
    /XA { 3 array astore /tzung_strokergb exch def } bind def


    /F { tzung_compound 0 eq {
             tzung_fillrule 0 eq { fill } { eofill } ifelse
         } {
             /tzung_closeop {F} def
         } ifelse } bind def
    /f { closepath F } bind def
    /S { tzung_compound 0 eq {
            tzung_strokergb aload pop setrgbcolor stroke
        } {
             /tzung_closeop {S} def
        } ifelse } bind def
    /s { closepath S } bind def

    /B { tzung_compound 0 eq {
            gsave
            tzung_fillrule 0 eq { fill } { eofill } ifelse
            grestore
            tzung_strokergb aload pop setrgbcolor stroke
         } {
             /tzung_closeop {B} def
        } ifelse } bind def
    /b { closepath B } bind def
    /H { tzung_compound 0 eq {
        }{
            /tzung_closeop {H} def
        } ifelse} bind def
    /h { closepath } bind def
    /N { tzung_compound 0 eq {
        }{
            /tzung_closeop {N} def
        } ifelse} bind def
    /n { closepath N } bind def


    /Bn { /dict_gradients exch dict def} bind def
    /Bd { /tmp_ngradstop exch def /tmp_shadingtype exch def } bind def  %leaves gradient name in stack
    /BD { ]  % this handles only stops that have CMYKRGB color definitions
        % linear gradient stops must be in reverse order, radials in normal order
        aload
        pop
        /tmp_boundaries tmp_ngradstop array def
        /tmp_colors tmp_ngradstop array def
        tmp_shadingtype 0 eq {
            0 1 tmp_ngradstop 1 sub   % for i=0; i<= number of gradient stops - 1; i++
        } {
            tmp_ngradstop 1 sub -1 0   % for i=number of gradient stops - 1; i >= 0; i++
        } ifelse
        {
            /loopvar exch def
            100 div
            tmp_boundaries  loopvar
            3 -1 roll put    %  obj array i => array i obj
            pop % assume gradient middle is always 50
            pop % assume color type is always 2 (CMYKRGB)
            3 array astore
            tmp_colors loopvar
            3 -1 roll put
            pop pop pop pop % drop CMYK values
        } for

        tmp_ngradstop 2 eq {
            /tmp_function 5 dict def
            tmp_boundaries 0 get tmp_boundaries 1 get 2 array astore
            tmp_function /Domain 3 -1 roll put
            tmp_function /FunctionType 2 put
            tmp_function /C0  tmp_colors 0 get put
            tmp_function /C1 tmp_colors 1 get put
            tmp_function /N 1 put

        } {
            /tmp_functions tmp_ngradstop 1 sub array def

            0 1 tmp_ngradstop 2 sub {
                /loopvar exch def
                /tmp_function 5 dict def
                tmp_function /Domain [0 1]  put
                tmp_function /FunctionType 2 put
                tmp_function /C0  tmp_colors loopvar get put
                tmp_function /C1 tmp_colors loopvar 1 add get put
                tmp_function /N 1 put
                tmp_functions loopvar tmp_function put
            } for


            /tmp_function 5 dict def
            tmp_boundaries 0 get tmp_boundaries tmp_ngradstop 1 sub get 2 array astore
            tmp_function /Domain 3 -1 roll  put
            tmp_function /FunctionType 3 put
            tmp_boundaries aload pop
            tmp_ngradstop -1 roll pop pop % remove first and last bounds
            tmp_ngradstop 2 sub array astore
            tmp_function /Bounds 3 -1 roll put
            tmp_function /Functions tmp_functions put

            tmp_ngradstop 1 sub {
                0 1
            } repeat
            tmp_ngradstop 1 sub 2 mul array astore
            tmp_function /Encode 3 -1 roll put

        } ifelse

        /tmp_shading 6 dict def
        tmp_shadingtype 0 eq {
            tmp_shading /ShadingType 2 put
            tmp_shading /Coords [ 0 0 1 0 ] put
        } {
            tmp_shading /ShadingType 3 put
            tmp_shading /Coords [ 0 0 0 0 0 1 ] put
        } ifelse
        tmp_shading /ColorSpace /DeviceRGB put
        tmp_shading /Domain [0 1] put
        tmp_shading /Extend[ true true] put
        tmp_shading /Function tmp_function put

        /tmp_gradient 2 dict def
        tmp_gradient /PatternType 2 put
        tmp_gradient /Shading tmp_shading put

        dict_gradients exch tmp_gradient put % gradient's name is on the top of the stack from Bd operator

    } bind def
    /Lb { 10 { pop } repeat } bind def
    /Ln { pop } bind def
    /Bb { } bind def

    /Bg {
        6 { pop } repeat
        gsave
        4 2 roll
        translate
        exch
        rotate
        dup scale
         exch pop % remove Bg flag
        dict_gradients exch get % now gradient name is on top of the stack
         [ 1 0 0 1 0 0 ]
        makepattern
        /pattern_tmp exch def
        grestore
        pattern_tmp  setpattern
         gsave % save for after pattern fil for possible stroke
    } def
    /BB { grestore 2 eq { s } if } bind def
    /LB { } bind def

} ifelse

%%EndProlog

%%BeginSetup
/Adobe_Illustrator_AI5 where
{
    pop
    Adobe_Illustrator_AI5 /initialize get exec
} if

1 Bn

%AI5_BeginGradient: (r_linearGradient5740)
(r_linearGradient5740) 1 2 Bd
[
1.000000 0.600000 0.000000 0.333333 0.000000 0.266667 0.666667 2 50 0.000000 %_Bs
1.000000 0.600000 0.000000 0.666667 0.000000 0.133333 0.333333 2 50 100.000000 %_Bs
BD
%AI5_EndGradient

%%EndSetup

%%Page: 1 1
%%BeginPageSetup
%%PageBoundingBox: 0 0 3750 2250
%%EndPageSetup


%AI5_BeginLayer
1 1 1 1 0 0 0 0 0 0 Lb
(Background) Ln

 
%AI3_Note: rect5128
 14.352378 w 3749.999717 0.000057 m 0.000000 0.000057 l 0.000000 
2249.999827 l 3749.999717 2249.999827 l 3749.999717 0.000057 l 
Bb 1 (r_linearGradient5740) 1875.001646 1125.000446 0 1874.999907 1 0 
0 1 0 0 Bg f 0 BB


LB
%AI5_EndLayer


%%Trailer
showpage
count op_count sub {pop} repeat
countdictstack dict_count sub {end} repeat
tzung_eps_state restore
end
%%EOF

